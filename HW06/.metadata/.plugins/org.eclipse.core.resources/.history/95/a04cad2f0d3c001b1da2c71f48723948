package hr.fer.oprpp1.math;

import java.util.List;

public class Complex {

	private double re;
	private double im;

	public static final Complex ZERO = new Complex(0, 0);
	public static final Complex ONE = new Complex(1, 0);
	public static final Complex ONE_NEG = new Complex(-1, 0);
	public static final Complex IM = new Complex(0, 1);
	public static final Complex IM_NEG = new Complex(0, -1);

	public Complex() {
		this(0, 0);
	}

	public Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}

	// returns module of complex number
	public double module() {
		return Math.abs(Math.sqrt(this.re*this.re + this.im*this.im));
	}

	// returns this*c
	public Complex multiply(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = this.re*c.re - this.im*c.im;
		num.im = this.re*c.im + this.im*c.re;
		return num;
	}

	// returns this/c
	public Complex divide(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = (this.re*c.re + this.im*c.im)/(c.re*c.re + c.im*c.im);
		num.im = (this.im*c.re - this.re*c.im)/(c.re*c.re + c.im*c.im);
		return num;
	}

	// returns this+c
	public Complex add(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = this.re + c.re;
		num.im = this.im + c.im;
		return num;
	}

	// returns this-c
	public Complex sub(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = this.re - c.re;
		num.im = this.im - c.im;
		return num;
	}

	// returns -this
	public Complex negate() {

	}

	// returns this^n, n is non-negative integer
	public Complex power(int n) {
		double th = this.getAngle();
		double mag = Math.pow(this.module(), n);
		
		Complex num = new Complex(0.0, 0.0);
		
		num.re = mag*Math.cos(n*th);
		num.im = mag*Math.sin(n*th);
		
		return num;
	}

	// returns n-th root of this, n is positive integer
	public List<Complex> root(int n) {
		Complex[] roots = new Complex[n];
		double angle;
		double tmp = Math.atan(this.im/this.re);
		
		if (this.getReal() > 0 && this.getImaginary() > 0) return tmp;
		else if (this.getReal() < 0 && this.getImaginary() > 0) return Math.PI + tmp;
		else if (this.getReal() < 0 && this.getImaginary() < 0) return Math.PI + tmp;
		else  return 2*Math.PI + tmp;

		double mag = Math.pow(this.module(), 1 / n);
		double ang = this.getAngle();

		for (int i = 0; i < n; i++) {
			Complex num = new Complex(0.0, 0.0);

			num.re = mag * Math.cos((ang + 2 * i * Math.PI) / n);
			num.im = mag * Math.sin((ang + 2 * i * Math.PI) / n);

			roots[i] = num;
		}

		return roots;
	}

	@Override
	public String toString() {
		String s = new String();
		if (this.getRe() != 0.0) {
			s = Double.toString(this.getRe());
		}

		if (this.getIm() != 0.0) {
			if (this.getIm() > 0) {
				s = s + "+";
			}
			if (this.getIm() != 1.0 && this.getIm() != -1.0) {
				s = s + Double.toString(this.getIm());
			} else if (this.getIm() == -1.0) {
				s = s + "-";
			}
			s = s + "i";
		}

		return s;
	}

	public double getRe() {
		return re;
	}

	public double getIm() {
		return im;
	}

}
