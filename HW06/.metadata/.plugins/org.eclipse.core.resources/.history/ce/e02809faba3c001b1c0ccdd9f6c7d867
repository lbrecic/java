package hr.fer.oprpp1.math;

import java.util.ArrayList;
import java.util.List;

public class Complex {

	private double re;
	private double im;

	public static final Complex ZERO = new Complex(0, 0);
	public static final Complex ONE = new Complex(1, 0);
	public static final Complex ONE_NEG = new Complex(-1, 0);
	public static final Complex IM = new Complex(0, 1);
	public static final Complex IM_NEG = new Complex(0, -1);

	public Complex() {
		this(0, 0);
	}

	public Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}

	// returns module of complex number
	public double module() {
		return Math.abs(Math.sqrt(this.re*this.re + this.im*this.im));
	}

	// returns this*c
	public Complex multiply(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = this.re*c.re - this.im*c.im;
		num.im = this.re*c.im + this.im*c.re;
		return num;
	}

	// returns this/c
	public Complex divide(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = (this.re*c.re + this.im*c.im)/(c.re*c.re + c.im*c.im);
		num.im = (this.im*c.re - this.re*c.im)/(c.re*c.re + c.im*c.im);
		return num;
	}

	// returns this+c
	public Complex add(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = this.re + c.re;
		num.im = this.im + c.im;
		return num;
	}

	// returns this-c
	public Complex sub(Complex c) {
		Complex num = new Complex(0.0, 0.0);
		num.re = this.re - c.re;
		num.im = this.im - c.im;
		return num;
	}

	// returns -this
	public Complex negate() {
		this.re = -re;
		this.im = -im;
		
		return this;
	}

	// returns this^n, n is non-negative integer
	public Complex power(int n) {
		double angle;
		double tmp = Math.atan(this.im/this.re);
		
		if (this.getRe() > 0 && this.getIm() > 0) angle = tmp;
		else if (this.getRe() < 0 && this.getIm() > 0) angle = Math.PI + tmp;
		else if (this.getRe() < 0 && this.getIm() < 0) angle = Math.PI + tmp;
		else  angle = 2*Math.PI + tmp;
		
		double mag = Math.pow(this.module(), n);
		
		Complex num = new Complex(0.0, 0.0);
		
		num.re = mag*Math.cos(n*angle);
		num.im = mag*Math.sin(n*angle);
		
		return num;
	}

	// returns n-th root of this, n is positive integer
	public List<Complex> root(int n) {
		List<Complex> roots = new ArrayList<>();
		double angle;
		double tmp = Math.atan(this.im/this.re);
		
		if (this.getRe() > 0 && this.getIm() > 0) angle = tmp;
		else if (this.getRe() < 0 && this.getIm() > 0) angle = Math.PI + tmp;
		else if (this.getRe() < 0 && this.getIm() < 0) angle = Math.PI + tmp;
		else  angle = 2*Math.PI + tmp;

		double mag = Math.pow(this.module(), 1 / n);

		for (int i = 0; i < n; i++) {
			Complex num = new Complex(0.0, 0.0);

			num.re = mag * Math.cos((angle + 2 * i * Math.PI) / n);
			num.im = mag * Math.sin((angle + 2 * i * Math.PI) / n);

			roots.add(num);
		}

		return roots;
	}

	@Override
	public String toString() {
		String s = new String();
		if (this.getRe() != 0.0) {
			s = Double.toString(this.getRe());
		}

		if (this.getIm() != 0.0) {
			if (this.getIm() > 0) {
				s = s + "+";
			}
			if (this.getIm() != 1.0 && this.getIm() != -1.0) {
				s = s + Double.toString(this.getIm());
			} else if (this.getIm() == -1.0) {
				s = s + "-";
			}
			s = s + "i";
		}

		return s;
	}

	public double getRe() {
		return re;
	}

	public double getIm() {
		return im;
	}

}
