package hr.fer.oprpp1.custom.collections;

public class LinkedListIndexedCollection extends Collection{
	private static class ListNode {
		private ListNode previous;
		private ListNode next;
		private Object value;
	}
	
	private int size;
	private ListNode first;
	private ListNode last;
	
	public LinkedListIndexedCollection() {
		first = last = null;
		this.size = 0;
	}
	
	public LinkedListIndexedCollection(Collection collection) {
		this.addAll(collection);
		this.size = collection.size();
	}
	
	public void add(Object value) {
		if (value == null) throw new NullPointerException();
		ListNode  item = new ListNode();
		item.value = value;
		if (this.first == null) {
			this.first = item;
			item.previous = null;
		} else {
			this.last.next = item;
			item.previous = this.last;
		}
		item.next = null;
		this.last = item;
		this.size++;
	}
	
	public Object get(int index) {
		if (index < 0 || index > this.size() - 1) throw new IndexOutOfBoundsException();
		ListNode iterator;
		if (index < this.size() / 2) {
			iterator = this.first;
		} else {
			index = this.size() - index;
			iterator = this.last;
		}
		while (index > 0) {
			iterator = iterator.next;
			index--;
		}
		return iterator.value;
	}
	
	public void clear() {
		this.first = this.last = null;
		this.size = 0;
	}
	
	public void insert(Object value, int position) {
		if (position < 0 || position > this.size()) throw new IndexOutOfBoundsException();
		if (value == null) throw new NullPointerException();
		ListNode iterator = this.first;
		while (position > 0) {
			iterator = iterator.next;
			position--;
		}
		ListNode item = new ListNode();
		item.value = value;
		item.next = iterator;
		item.previous = iterator.previous;
		iterator.previous.next = item;
		iterator.previous = item;
		this.size++;
	}
	
	public int indexOf(Object value) {
		if(value != null) {		
			ListNode iterator = first;
			for (int i = 0; i < this.size(); i++) {
				if (iterator.value.equals(value)) return i;
				iterator = iterator.next;
			}
		}
		return -1;
	}
	
	public void remove(int index) {
		if (index < 0 || index > this.size() - 1) throw new IndexOutOfBoundsException();
		ListNode iterator = first;
		for (int i = 0; i < index; i++) {
			iterator = iterator.next;
		}
		iterator.previous.next = iterator.next;
		iterator.next.previous  = iterator.previous;
		this.size--;
	}
	
	public boolean isEmpty() {
		return this.size() == 0;
	}
	
	public int size() {
		return this.size;
	}
	
	public boolean contains(Object value) {
		if (value != null) {
			ListNode iterator = first;
			for (int i = 0; i < this.size(); i++) {
				if (iterator.value.equals(value)) return true;
				iterator = iterator.next;
			}
		}
		return false;
	}
	
	public boolean remove(Object value) {
		if (this.contains(value)) {
			ListNode iterator = first;
			for (int i = 0; i < this.size(); i++) {
				if (iterator.value.equals(value)) {
					iterator.previous.next = iterator.next;
					iterator.next.previous  = iterator.previous;
					this.size--;
					return true;
				}
				iterator = iterator.next;
			}
		}	
		return false;
	}
	
	public Object[] toArray() {
		Object[] arr = new Object[this.size()];
		int i = 0;
		ListNode iterator = this.first;
		while (iterator != null) {
			arr[i] = iterator.value;
			iterator = iterator.next;
			i++;
		}
		return arr;
	}
	
	public void forEach(Processor processor) {
		ListNode iterator = first;
		while (iterator != null) {
			processor.process(iterator.value);
			iterator = iterator.next;
		}
	}
	
	public void addAll(Collection other) {
		class AddAllProcessor extends Processor {
			public void process(Object value) {
				add(value);
			}
		};
		
		other.forEach(new AddAllProcessor());
	}
}
